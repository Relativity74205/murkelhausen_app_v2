# generated by datamodel-codegen:
#   filename:  departure.json
#   timestamp: 2023-08-12T05:39:31+00:00

from __future__ import annotations

import datetime
from typing import List, Optional

from pydantic import BaseModel


class Parameter(BaseModel):
    name: str
    value: str


class Input(BaseModel):
    input: str


class Ref(BaseModel):
    id: str
    gid: str
    omc: str
    placeID: str
    place: str
    coords: str


class Point(BaseModel):
    usage: str
    type: str
    name: str
    stateless: str
    tariffArea: str
    tariffAreaName: str
    tariffLayer1: str
    tariffLayer2: str
    ref: Ref
    infos: None


class Points(BaseModel):
    point: Point


class Dm(BaseModel):
    input: Input
    points: Points | None = None


class Arr(BaseModel):
    input: Input
    points: Points | None = None


class ValidityDates(BaseModel):
    deparr: str
    ttpFrom: str
    ttpTo: str
    year: str
    month: str
    day: str
    hour: str
    minute: str


class DateRangeItem(BaseModel):
    day: str
    month: str
    year: str
    weekday: str


class ExcludedMean(BaseModel):
    value: str
    selected: str


class PtOption(BaseModel):
    active: str
    maxChanges: str
    maxTime: str
    maxWait: str
    routeType: str
    changeSpeed: str
    lineRestriction: str
    useProxFootSearch: str
    useProxFootSearchOrigin: str
    useProxFootSearchDestination: str
    bike: str
    plane: str
    noCrowded: str
    noSolidStairs: str
    noEscalators: str
    noElevators: str
    lowPlatformVhcl: str
    wheelchair: str
    needElevatedPlt: str
    assistance: str
    SOSAvail: str
    noLonelyTransfer: str
    illumTransfer: str
    overgroundTransfer: str
    noInsecurePlaces: str
    privateTransport: str
    excludedMeans: List[ExcludedMean]
    activeImp: str
    activeCom: str
    activeSec: str


class Option(BaseModel):
    ptOption: PtOption


class Diva(BaseModel):
    branch: str
    line: str
    supplement: str
    dir: str
    project: str
    network: str
    stateless: str
    globalId: str | None = None
    tripCode: str
    operator: str
    opCode: str
    vF: str
    vTo: str
    lineDisplay: str
    isSTT: str | None = None
    isROP: str | None = None
    attrs: List


class Mode(BaseModel):
    name: str
    number: str
    product: str
    productId: str
    type: str
    code: str
    destination: str
    destID: str
    desc: str
    timetablePeriod: str
    diva: Diva


class Line(BaseModel):
    mode: Mode
    index: str


class ServingLines(BaseModel):
    lines: List[Line]


class DateTime(BaseModel):
    year: int
    month: int
    day: int
    weekday: int
    hour: int
    minute: int

    def __sub__(self, other):
        return (
            (self.hour - other.hour) * 60 + self.minute - other.minute
        )  # TODO add handling for bigger deltas

    @property
    def time(self) -> datetime.time:
        return datetime.time(self.hour, self.minute)


class LiErgRiProj(BaseModel):
    line: str
    project: str
    direction: str
    supplement: str
    network: str
    gid: str | None = None


class ServingLine(BaseModel):
    key: str
    code: str
    number: str
    symbol: str
    motType: str
    mtSubcode: str
    realtime: str
    direction: str
    directionFrom: str
    name: str
    liErgRiProj: LiErgRiProj
    destID: str
    stateless: str
    lineDisplay: str
    delay: Optional[str] = None


class Operator(BaseModel):
    code: str
    name: str
    publicCode: str


class Attr(BaseModel):
    name: str
    value: str


class DepartureListItem(BaseModel):
    stopID: str
    x: str
    y: str
    mapName: str
    area: str
    platform: str
    platformName: str
    stopName: str
    nameWO: str
    countdown: str
    dateTime: DateTime
    realDateTime: DateTime | None = None
    realtimeTripStatus: str | None = (
        None  # TODO check which are possible values; MONITORED
    )
    servingLine: ServingLine
    operator: Operator | None = None
    attrs: list[Attr] | None = None

    @property
    def planned_departure_time(self) -> str:
        return f"{self.dateTime.hour:02}:{self.dateTime.minute:02}"

    @property
    def departure_time(self) -> str:
        if self.realDateTime is None:
            return self.planned_departure_time

    @property
    def delay(self) -> int:
        # TODO add realtimeTripStatus handling
        if self.realDateTime is None:
            return 0
        else:
            return self.realDateTime - self.dateTime

    @property
    def richtung(self) -> str:
        return f"{self.servingLine.direction} (aus {self.servingLine.directionFrom})"


class Data(BaseModel):
    parameters: list[Parameter]
    # dm: Dm
    # arr: Arr
    dateTime: ValidityDates
    dateRange: list[DateRangeItem]
    option: Option
    servingLines: ServingLines
    departureList: list[DepartureListItem]


class Coords(BaseModel):
    lat: str
    long: str


class Stop(BaseModel):
    trafficInfos: list
    elevators: list
    escalators: list
    name: str
    additionalName: str
    isAccessible: bool
    hasTactileStrip: bool
    hasRamp: bool
    hasMobileRamp: bool
    coords: Coords


class Station(BaseModel):
    trafficInfos: list
    elevators: list
    escalators: list
    stops: list[Stop]
    id: str
    globalID: str
    name: str
    city: str
    coords: Coords
    type: str
    stationPlanUrl: str


class DepartureModel(BaseModel):
    requestType: str
    statusCode: int
    data: Data
    station: Station

    def get_departure_list(self) -> list[DepartureListItem]:
        return self.data.departureList

    def get_departure_list_per_line(self, line: str) -> list[DepartureListItem]:
        return [
            departure
            for departure in self.data.departureList
            if departure.servingLine.number == line
        ]

    def get_departure_list_per_line_and_direction(
        self, line: str, direction: str
    ) -> list[DepartureListItem]:
        return [
            departure
            for departure in self.data.departureList
            if departure.servingLine.number == line
            and departure.servingLine.direction == direction
        ]
